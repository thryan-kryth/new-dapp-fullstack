// RPC Provider Hooks
// Generated by Cradle

'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import { usePublicClient } from 'wagmi';
import type { PublicClient } from 'viem';
import {
  checkProviderHealth,
  createHealthMonitor,
  type ProviderHealthStatus,
} from '@/lib/rpc/health-check';
import {
  getPublicClient,
  clearClientCache,
} from '@/lib/rpc/client-factory';
import { RPC_CONFIG, type ProviderName } from '@/lib/rpc/provider-config';

export interface UseProviderReturn {
  // Client
  client: PublicClient;
  
  // Health status
  healthStatus: ProviderHealthStatus | null;
  isHealthy: boolean;
  currentProvider: ProviderName | null;
  
  // Actions
  refreshHealth: () => Promise<void>;
  switchProvider: (provider: ProviderName) => void;
}

/**
 * Hook for RPC provider management with health monitoring
 */
export function useProvider(): UseProviderReturn {
  const wagmiClient = usePublicClient();
  const [healthStatus, setHealthStatus] = useState<ProviderHealthStatus | null>(null);
  const [preferredProvider, setPreferredProvider] = useState<ProviderName | null>(null);
  
  // Get the best available client
  const client = useMemo(() => {
    if (preferredProvider) {
      // TODO: Get client for specific provider
      return getPublicClient();
    }
    return wagmiClient ?? getPublicClient();
  }, [wagmiClient, preferredProvider]);
  
  // Refresh health status
  const refreshHealth = useCallback(async () => {
    const status = await checkProviderHealth();
    setHealthStatus(status);
    
    // Clear cache if best provider changed
    if (status.bestProvider !== healthStatus?.bestProvider) {
      clearClientCache();
    }
  }, [healthStatus?.bestProvider]);
  
  // Switch to a specific provider
  const switchProvider = useCallback((provider: ProviderName) => {
    setPreferredProvider(provider);
    clearClientCache();
  }, []);
  
  // Start health monitoring
  useEffect(() => {
    const monitor = createHealthMonitor(
      setHealthStatus,
      RPC_CONFIG.healthCheckInterval
    );
    
    monitor.start();
    
    return () => {
      monitor.stop();
    };
  }, []);
  
  const isHealthy = healthStatus?.healthyProviders.length ?? 0 > 0;
  const currentProvider = preferredProvider ?? healthStatus?.bestProvider ?? RPC_CONFIG.primaryProvider;
  
  return {
    client,
    healthStatus,
    isHealthy,
    currentProvider,
    refreshHealth,
    switchProvider,
  };
}

/**
 * Hook for getting provider health status
 */
export function useProviderHealth() {
  const [status, setStatus] = useState<ProviderHealthStatus | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    checkProviderHealth()
      .then(setStatus)
      .finally(() => setIsLoading(false));
  }, []);
  
  return { status, isLoading };
}

/**
 * Hook for tracking connection quality
 */
export function useConnectionQuality() {
  const { healthStatus } = useProvider();
  
  if (!healthStatus) {
    return { quality: 'unknown' as const, latency: null };
  }
  
  const bestLatency = healthStatus.results
    .filter(r => r.healthy)
    .map(r => r.latency)
    .filter((l): l is number => l !== null)
    .sort((a, b) => a - b)[0];
  
  let quality: 'excellent' | 'good' | 'fair' | 'poor' | 'disconnected';
  
  if (!bestLatency) {
    quality = 'disconnected';
  } else if (bestLatency < 100) {
    quality = 'excellent';
  } else if (bestLatency < 300) {
    quality = 'good';
  } else if (bestLatency < 1000) {
    quality = 'fair';
  } else {
    quality = 'poor';
  }
  
  return { quality, latency: bestLatency ?? null };
}