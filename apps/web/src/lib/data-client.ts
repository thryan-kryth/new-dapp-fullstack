// Alchemy Data Client
// Generated by Cradle

import { Alchemy, Network, type OwnedNft, type TokenBalance } from 'alchemy-sdk';
import type { Address } from 'viem';

const apiKey = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;

if (!apiKey) {
  console.warn('Missing NEXT_PUBLIC_ALCHEMY_API_KEY');
}

export const alchemy = new Alchemy({
  apiKey: apiKey ?? '',
  network: Network.ARB_MAINNET,
});

export interface TokenData {
  address: Address;
  symbol: string;
  name: string;
  decimals: number;
  balance: string;
  logo?: string;
  price?: number;
}

export interface NFTData {
  tokenId: string;
  contractAddress: Address;
  name: string;
  description?: string;
  image?: string;
  collection?: string;
}

export async function getTokenBalances(address: Address): Promise<TokenData[]> {
  const balances = await alchemy.core.getTokenBalances(address);
  
  const tokens: TokenData[] = [];
  for (const balance of balances.tokenBalances) {
    if (balance.tokenBalance === '0x0') continue;
    
    try {
      const metadata = await alchemy.core.getTokenMetadata(balance.contractAddress);
      tokens.push({
        address: balance.contractAddress as Address,
        symbol: metadata.symbol ?? 'UNKNOWN',
        name: metadata.name ?? 'Unknown Token',
        decimals: metadata.decimals ?? 18,
        balance: balance.tokenBalance ?? '0',
        logo: metadata.logo ?? undefined,
      });
    } catch {
      // Skip tokens without metadata
    }
  }
  
  return tokens;
}

export async function getNFTs(address: Address): Promise<NFTData[]> {
  const nfts = await alchemy.nft.getNftsForOwner(address);
  
  return nfts.ownedNfts.map((nft) => ({
    tokenId: nft.tokenId,
    contractAddress: nft.contract.address as Address,
    name: nft.name ?? `#${nft.tokenId}`,
    description: nft.description,
    image: nft.image?.cachedUrl ?? nft.image?.originalUrl,
    collection: nft.contract.name,
  }));
}

export async function getTransactionHistory(address: Address, limit = 50) {
  const transfers = await alchemy.core.getAssetTransfers({
    fromAddress: address,
    category: ['external', 'erc20', 'erc721', 'erc1155'],
    maxCount: limit,
    order: 'desc',
  });
  
  return transfers.transfers;
}