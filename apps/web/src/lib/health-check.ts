// RPC Provider Health Check
// Generated by Cradle

import { createPublicClient, http, type PublicClient } from 'viem';
import { arbitrum } from 'viem/chains';
import {
  getAllProviderEndpoints,
  type ProviderName,
  type ProviderEndpoint,
} from './provider-config';

export interface HealthCheckResult {
  provider: ProviderName;
  healthy: boolean;
  latency: number | null;
  blockNumber: bigint | null;
  error?: string;
}

export interface ProviderHealthStatus {
  results: HealthCheckResult[];
  healthyProviders: ProviderName[];
  bestProvider: ProviderName | null;
  timestamp: number;
}

/**
 * Check health of a single provider
 */
async function checkSingleProvider(
  endpoint: ProviderEndpoint
): Promise<HealthCheckResult> {
  const startTime = Date.now();
  
  try {
    const client = createPublicClient({
      chain: arbitrum,
      transport: http(endpoint.http, { timeout: 5000 }),
    });
    
    const blockNumber = await client.getBlockNumber();
    const latency = Date.now() - startTime;
    
    return {
      provider: endpoint.name,
      healthy: true,
      latency,
      blockNumber,
    };
  } catch (error) {
    return {
      provider: endpoint.name,
      healthy: false,
      latency: null,
      blockNumber: null,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Check health of all configured providers
 */
export async function checkProviderHealth(): Promise<ProviderHealthStatus> {
  const endpoints = getAllProviderEndpoints('arbitrum');
  
  const results = await Promise.all(
    endpoints.map(e => checkSingleProvider(e))
  );
  
  const healthyProviders = results
    .filter(r => r.healthy)
    .sort((a, b) => (a.latency ?? Infinity) - (b.latency ?? Infinity))
    .map(r => r.provider);
  
  return {
    results,
    healthyProviders,
    bestProvider: healthyProviders[0] ?? null,
    timestamp: Date.now(),
  };
}

/**
 * Monitor provider health continuously
 */
export function createHealthMonitor(
  onHealthUpdate: (status: ProviderHealthStatus) => void,
  interval: number = 30000
): { start: () => void; stop: () => void } {
  let timerId: NodeJS.Timeout | null = null;
  
  const check = async () => {
    const status = await checkProviderHealth();
    onHealthUpdate(status);
  };
  
  return {
    start: () => {
      check(); // Initial check
      timerId = setInterval(check, interval);
    },
    stop: () => {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
    },
  };
}

// CLI support for running health checks
if (typeof require !== 'undefined' && require.main === module) {
  checkProviderHealth().then(status => {
    console.log('Provider Health Status:');
    console.log('=======================');
    
    for (const result of status.results) {
      const statusIcon = result.healthy ? '✓' : '✗';
      const latency = result.latency ? `${result.latency}ms` : 'N/A';
      console.log(`${statusIcon} ${result.provider}: ${latency}`);
      if (result.error) {
        console.log(`  Error: ${result.error}`);
      }
    }
    
    console.log('');
    console.log(`Best Provider: ${status.bestProvider ?? 'None available'}`);
  });
}